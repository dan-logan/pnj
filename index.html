<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pegs and Jokers</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useEffect, useCallback } = React;

const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
const TRACK_LENGTH = 72;
const PLAYER_COLORS = ['#F59E0B', '#3B82F6', '#EC4899', '#10B981'];
const PLAYER_NAMES = ['You (Yellow)', 'Blue (AI)', 'Pink (AI)', 'Green (AI)'];

const CARD_VALUES = {
  'A': { value: 1, canStart: true },
  '2': { value: 2 },
  '3': { value: 3 },
  '4': { value: 4 },
  '5': { value: 5 },
  '6': { value: 6 },
  '7': { value: 7, canSplit: true },
  '8': { value: -8, backward: true },
  '9': { value: 9, mustSplit: true },
  '10': { value: 10 },
  'J': { value: 11, canStart: true },
  'Q': { value: 12, canStart: true },
  'K': { value: 13, canStart: true },
  'Joker': { isJoker: true, canStart: true }
};

function createDeck() {
  const deck = [];
  let id = 0;
  for (let i = 0; i < 2; i++) {
    for (const suit of SUITS) {
      for (const rank of RANKS) {
        deck.push({ rank, suit, id: id++ });
      }
    }
    deck.push({ rank: 'Joker', suit: 'ðŸƒ', id: id++ });
    deck.push({ rank: 'Joker', suit: 'ðŸƒ', id: id++ });
  }
  return shuffle(deck);
}

function shuffle(array) {
  const arr = [...array];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function getStartPosition(player) {
  return player * 18 + 8;
}

function getHomeEntrance(player) {
  return player * 18 + 3;
}

function getDistanceToHome(peg, player) {
  if (peg.location === 'home') {
    return 4 - peg.homePosition;
  }
  if (peg.location === 'start') {
    return 100;
  }
  const homeEntrance = getHomeEntrance(player);
  const homeEntryPoint = (homeEntrance + 1) % TRACK_LENGTH;
  let stepsToEntry = (homeEntryPoint - peg.position + TRACK_LENGTH) % TRACK_LENGTH;
  if (stepsToEntry === 0) stepsToEntry = TRACK_LENGTH;
  return stepsToEntry + 5;
}

function PegsAndJokers() {
  const [deck, setDeck] = useState([]);
  const [discardPiles, setDiscardPiles] = useState([[], [], [], []]);
  const [stuckCounts, setStuckCounts] = useState([0, 0, 0, 0]);
  const [hands, setHands] = useState([[], [], [], []]);
  const [pegs, setPegs] = useState([
    Array(5).fill(null).map((_, i) => ({ location: 'start', index: i })),
    Array(5).fill(null).map((_, i) => ({ location: 'start', index: i })),
    Array(5).fill(null).map((_, i) => ({ location: 'start', index: i })),
    Array(5).fill(null).map((_, i) => ({ location: 'start', index: i }))
  ]);
  const [currentPlayer, setCurrentPlayer] = useState(0);
  const [selectedCard, setSelectedCard] = useState(null);
  const [selectedPeg, setSelectedPeg] = useState(null);
  const [splitRemaining, setSplitRemaining] = useState(0);
  const [splitCard, setSplitCard] = useState(null);
  const [jokerMode, setJokerMode] = useState(false);
  const [jokerSourcePeg, setJokerSourcePeg] = useState(null);
  const [discardMode, setDiscardMode] = useState(false);
  const [gameMessage, setGameMessage] = useState('Your turn! Select a card and peg to move.');
  const [winner, setWinner] = useState(null);

  const initGame = useCallback(() => {
    const newDeck = createDeck();
    const hand1 = newDeck.splice(0, 6);
    const hand2 = newDeck.splice(0, 6);
    const hand3 = newDeck.splice(0, 6);
    const hand4 = newDeck.splice(0, 6);
    setDeck(newDeck);
    setDiscardPiles([[], [], [], []]);
    setStuckCounts([0, 0, 0, 0]);
    setHands([hand1, hand2, hand3, hand4]);
    setPegs([
      Array(5).fill(null).map((_, i) => ({ location: 'start', index: i })),
      Array(5).fill(null).map((_, i) => ({ location: 'start', index: i })),
      Array(5).fill(null).map((_, i) => ({ location: 'start', index: i })),
      Array(5).fill(null).map((_, i) => ({ location: 'start', index: i }))
    ]);
    setCurrentPlayer(0);
    setSelectedCard(null);
    setSelectedPeg(null);
    setSplitRemaining(0);
    setSplitCard(null);
    setJokerMode(false);
    setJokerSourcePeg(null);
    setDiscardMode(false);
    setGameMessage('Your turn! Select a card and peg to move.');
    setWinner(null);
  }, []);

  useEffect(() => {
    initGame();
  }, [initGame]);

  const drawCard = useCallback((currentDeck, allDiscardPiles) => {
    if (currentDeck.length === 0) {
      const allDiscards = allDiscardPiles.flat();
      if (allDiscards.length === 0) {
        return { card: null, newDeck: [], newDiscardPiles: [[], [], [], []] };
      }
      const reshuffled = shuffle([...allDiscards]);
      return { card: reshuffled.pop(), newDeck: reshuffled, newDiscardPiles: [[], [], [], []] };
    }
    const newDeck = [...currentDeck];
    return { card: newDeck.pop(), newDeck, newDiscardPiles: allDiscardPiles };
  }, []);

  const findPegAtPosition = useCallback((position, playerPegs) => {
    for (let p = 0; p < 4; p++) {
      for (let i = 0; i < 5; i++) {
        const peg = playerPegs[p][i];
        if (peg.location === 'track' && peg.position === position) {
          return { player: p, pegIndex: i };
        }
      }
    }
    return null;
  }, []);

  const isValidMove = useCallback((player, pegIndex, card, currentPegs, moveAmount = null) => {
    const peg = currentPegs[player][pegIndex];
    const cardInfo = CARD_VALUES[card.rank];
    
    if (peg.location === 'home') {
      if (cardInfo.isJoker || cardInfo.backward) return false;
      if (cardInfo.mustSplit) {
        if (moveAmount === null || moveAmount <= 0) return false;
      }
      const amount = moveAmount !== null ? moveAmount : cardInfo.value;
      if (amount <= 0) return false;
      const newHomePos = peg.homePosition + amount;
      if (newHomePos > 4) return false;
      const homeOccupied = currentPegs[player].some(
        p => p.location === 'home' && p.homePosition === newHomePos
      );
      if (homeOccupied) return false;
      for (let pos = peg.homePosition + 1; pos < newHomePos; pos++) {
        const blocked = currentPegs[player].some(
          p => p.location === 'home' && p.homePosition === pos
        );
        if (blocked) return false;
      }
      return true;
    }
    
    if (peg.location === 'start') {
      if (cardInfo.isJoker) {
        for (let p = 0; p < 4; p++) {
          if (p === player) continue;
          for (let i = 0; i < 5; i++) {
            if (currentPegs[p][i].location === 'track') return true;
          }
        }
        return false;
      }
      const startPos = getStartPosition(player);
      const ownPegAtStart = currentPegs[player].some(
        p => p.location === 'track' && p.position === startPos
      );
      if (ownPegAtStart) return false;
      return cardInfo.canStart;
    }
    
    if (cardInfo.isJoker) {
      for (let p = 0; p < 4; p++) {
        if (p === player) continue;
        for (let i = 0; i < 5; i++) {
          const otherPeg = currentPegs[p][i];
          if (otherPeg.location === 'track') return true;
        }
      }
      return false;
    }
    
    const amount = moveAmount !== null ? moveAmount : cardInfo.value;
    const homeEntrance = getHomeEntrance(player);
    const currentPos = peg.position;
    
    let newPos;
    if (amount > 0) {
      newPos = (currentPos + amount) % TRACK_LENGTH;
    } else {
      newPos = (currentPos + amount + TRACK_LENGTH) % TRACK_LENGTH;
    }
    
    if (amount > 0) {
      let stepsToHome = 0;
      for (let step = 1; step <= amount; step++) {
        const checkPos = (currentPos + step) % TRACK_LENGTH;
        if (checkPos === (homeEntrance + 1) % TRACK_LENGTH && stepsToHome === 0) {
          stepsToHome = step;
        }
      }
      
      if (stepsToHome > 0 && stepsToHome <= amount) {
        const homeSteps = amount - stepsToHome;
        if (homeSteps >= 0 && homeSteps < 5) {
          const homeOccupied = currentPegs[player].some(
            p => p.location === 'home' && p.homePosition === homeSteps
          );
          if (!homeOccupied) {
            let trackBlocked = false;
            for (let step = 1; step < stepsToHome; step++) {
              const checkPos = (currentPos + step) % TRACK_LENGTH;
              const pegAtCheck = findPegAtPosition(checkPos, currentPegs);
              if (pegAtCheck && pegAtCheck.player === player) {
                trackBlocked = true;
                break;
              }
            }
            let homeBlocked = false;
            for (let homePos = 0; homePos < homeSteps; homePos++) {
              const blocked = currentPegs[player].some(
                p => p.location === 'home' && p.homePosition === homePos
              );
              if (blocked) {
                homeBlocked = true;
                break;
              }
            }
            if (!trackBlocked && !homeBlocked) {
              return true;
            }
          }
        }
      }
    }
    
    const pegAtNewPos = findPegAtPosition(newPos, currentPegs);
    if (pegAtNewPos && pegAtNewPos.player === player) {
      return false;
    }
    
    const direction = amount > 0 ? 1 : -1;
    for (let step = direction; Math.abs(step) < Math.abs(amount); step += direction) {
      const checkPos = (currentPos + step + TRACK_LENGTH) % TRACK_LENGTH;
      const pegAtCheck = findPegAtPosition(checkPos, currentPegs);
      if (pegAtCheck && pegAtCheck.player === player) {
        return false;
      }
    }
    
    return true;
  }, [findPegAtPosition]);

  const hasAnyValidMove = useCallback((player, hand, currentPegs) => {
    for (const card of hand) {
      const cardInfo = CARD_VALUES[card.rank];
      for (let pegIndex = 0; pegIndex < 5; pegIndex++) {
        if (isValidMove(player, pegIndex, card, currentPegs)) {
          return true;
        }
        if (cardInfo.canSplit) {
          for (let split = 1; split <= 6; split++) {
            if (isValidMove(player, pegIndex, card, currentPegs, split)) {
              return true;
            }
          }
        }
        if (cardInfo.mustSplit) {
          for (let forward = 1; forward <= 8; forward++) {
            if (isValidMove(player, pegIndex, card, currentPegs, forward)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }, [isValidMove]);

  const executeMoveInternal = useCallback((player, pegIndex, card, amount, currentPegs) => {
    const newPegs = currentPegs.map(p => p.map(peg => ({ ...peg })));
    const peg = newPegs[player][pegIndex];
    const cardInfo = CARD_VALUES[card.rank];
    
    if (peg.location === 'home') {
      const moveAmount = amount !== null ? amount : cardInfo.value;
      peg.homePosition = peg.homePosition + moveAmount;
      return { newPegs, bumpedOpponent: false };
    }
    
    if (peg.location === 'start' && cardInfo.canStart && !cardInfo.isJoker) {
      const startPos = getStartPosition(player);
      const pegAtStart = findPegAtPosition(startPos, newPegs);
      let bumpedOpponent = false;
      if (pegAtStart && pegAtStart.player !== player) {
        newPegs[pegAtStart.player][pegAtStart.pegIndex] = { location: 'start', index: pegAtStart.pegIndex };
        bumpedOpponent = true;
      }
      peg.location = 'track';
      peg.position = startPos;
      return { newPegs, bumpedOpponent };
    }
    
    if (cardInfo.isJoker) {
      for (let p = 0; p < 4; p++) {
        if (p === player) continue;
        for (let i = 0; i < 5; i++) {
          const otherPeg = newPegs[p][i];
          if (otherPeg.location === 'track') {
            const targetPos = otherPeg.position;
            newPegs[p][i] = { location: 'start', index: i };
            peg.location = 'track';
            peg.position = targetPos;
            return { newPegs, bumpedOpponent: true };
          }
        }
      }
      return { newPegs, bumpedOpponent: false };
    }
    
    const homeEntrance = getHomeEntrance(player);
    const currentPos = peg.position;
    const moveAmount = amount !== null ? amount : cardInfo.value;
    
    let shouldEnterHome = false;
    let homeSteps = 0;
    
    if (moveAmount > 0) {
      let stepsToHome = 0;
      for (let step = 1; step <= moveAmount; step++) {
        const checkPos = (currentPos + step) % TRACK_LENGTH;
        if (checkPos === (homeEntrance + 1) % TRACK_LENGTH && stepsToHome === 0) {
          stepsToHome = step;
        }
      }
      
      if (stepsToHome > 0 && stepsToHome <= moveAmount) {
        homeSteps = moveAmount - stepsToHome;
        if (homeSteps >= 0 && homeSteps < 5) {
          const homeOccupied = newPegs[player].some(
            p => p.location === 'home' && p.homePosition === homeSteps
          );
          if (!homeOccupied) {
            let trackBlocked = false;
            for (let step = 1; step < stepsToHome; step++) {
              const checkPos = (currentPos + step) % TRACK_LENGTH;
              const pegAtCheck = findPegAtPosition(checkPos, newPegs);
              if (pegAtCheck && pegAtCheck.player === player) {
                trackBlocked = true;
                break;
              }
            }
            let homeBlocked = false;
            for (let homePos = 0; homePos < homeSteps; homePos++) {
              const blocked = newPegs[player].some(
                p => p.location === 'home' && p.homePosition === homePos
              );
              if (blocked) {
                homeBlocked = true;
                break;
              }
            }
            if (!trackBlocked && !homeBlocked) {
              shouldEnterHome = true;
            }
          }
        }
      }
    }
    
    if (shouldEnterHome) {
      peg.location = 'home';
      peg.homePosition = homeSteps;
      return { newPegs, bumpedOpponent: false };
    }
    
    let newPos;
    if (moveAmount > 0) {
      newPos = (currentPos + moveAmount) % TRACK_LENGTH;
    } else {
      newPos = (currentPos + moveAmount + TRACK_LENGTH) % TRACK_LENGTH;
    }
    
    const pegAtNewPos = findPegAtPosition(newPos, newPegs);
    if (pegAtNewPos && pegAtNewPos.player !== player) {
      newPegs[pegAtNewPos.player][pegAtNewPos.pegIndex] = { location: 'start', index: pegAtNewPos.pegIndex };
    }
    
    peg.position = newPos;
    return { newPegs, bumpedOpponent: !!pegAtNewPos };
  }, [findPegAtPosition]);

  const checkWinner = useCallback((currentPegs) => {
    for (let p = 0; p < 4; p++) {
      if (currentPegs[p].every(peg => peg.location === 'home')) {
        return p;
      }
    }
    return null;
  }, []);

  const executeMove = useCallback((player, pegIndex, card, splitAmount = null) => {
    if (!isValidMove(player, pegIndex, card, pegs, splitAmount)) {
      setGameMessage('Invalid move. Try again.');
      return false;
    }
    
    const { newPegs } = executeMoveInternal(player, pegIndex, card, splitAmount, pegs);
    setPegs(newPegs);
    
    const cardInfo = CARD_VALUES[card.rank];
    
    if (cardInfo.canSplit && splitAmount !== null && splitAmount < 7) {
      const remaining = 7 - splitAmount;
      setSplitRemaining(remaining);
      setSplitCard(card);
      setSelectedPeg(null);
      setGameMessage(`Move remaining ${remaining} spaces with another peg.`);
      return true;
    }
    
    if (cardInfo.mustSplit && splitAmount !== null) {
      const remaining = -(9 - splitAmount);
      setSplitRemaining(remaining);
      setSplitCard(card);
      setSelectedPeg(null);
      const direction = remaining > 0 ? 'forward' : 'backward';
      setGameMessage(`Move ${Math.abs(remaining)} spaces ${direction} with another peg.`);
      return true;
    }
    
    const w = checkWinner(newPegs);
    if (w !== null) {
      setWinner(w);
      return true;
    }
    
    const newHands = hands.map(h => [...h]);
    const cardIndex = newHands[player].findIndex(c => c.id === card.id);
    const discarded = newHands[player].splice(cardIndex, 1)[0];
    const newDiscardPiles = discardPiles.map((pile, i) => 
      i === player ? [...pile, discarded] : [...pile]
    );
    const { card: newCard, newDeck, newDiscardPiles: updatedDiscardPiles } = drawCard(deck, newDiscardPiles);
    if (newCard) newHands[player].push(newCard);
    
    setHands(newHands);
    setDeck(newDeck);
    setDiscardPiles(updatedDiscardPiles);
    const newStuckCounts = [...stuckCounts];
    newStuckCounts[player] = 0;
    setStuckCounts(newStuckCounts);
    setSelectedCard(null);
    setSelectedPeg(null);
    setSplitRemaining(0);
    setSplitCard(null);
    
    const nextPlayer = (player + 1) % 4;
    setCurrentPlayer(nextPlayer);
    setGameMessage(`${PLAYER_NAMES[nextPlayer]} is thinking...`);
    
    return true;
  }, [isValidMove, pegs, executeMoveInternal, checkWinner, hands, deck, discardPiles, stuckCounts, drawCard]);

  const completeSplit = useCallback((pegIndex, amount) => {
    if (!isValidMove(currentPlayer, pegIndex, splitCard, pegs, amount)) {
      setGameMessage('Invalid move for split. Try again.');
      return false;
    }
    
    const { newPegs } = executeMoveInternal(currentPlayer, pegIndex, splitCard, amount, pegs);
    setPegs(newPegs);
    
    const w = checkWinner(newPegs);
    if (w !== null) {
      setWinner(w);
      return true;
    }
    
    const newHands = hands.map(h => [...h]);
    const cardIndex = newHands[currentPlayer].findIndex(c => c.id === splitCard.id);
    const discarded = newHands[currentPlayer].splice(cardIndex, 1)[0];
    const newDiscardPiles = discardPiles.map((pile, i) => 
      i === currentPlayer ? [...pile, discarded] : [...pile]
    );
    const { card: newCard, newDeck, newDiscardPiles: updatedDiscardPiles } = drawCard(deck, newDiscardPiles);
    if (newCard) newHands[currentPlayer].push(newCard);
    
    setHands(newHands);
    setDeck(newDeck);
    setDiscardPiles(updatedDiscardPiles);
    const newStuckCounts = [...stuckCounts];
    newStuckCounts[currentPlayer] = 0;
    setStuckCounts(newStuckCounts);
    setSelectedCard(null);
    setSelectedPeg(null);
    setSplitRemaining(0);
    setSplitCard(null);
    const nextPlayer = (currentPlayer + 1) % 4;
    setCurrentPlayer(nextPlayer);
    setGameMessage(`${PLAYER_NAMES[nextPlayer]} is thinking...`);
    
    return true;
  }, [currentPlayer, splitCard, pegs, isValidMove, executeMoveInternal, checkWinner, hands, deck, discardPiles, stuckCounts, drawCard]);

  const discardAndDraw = useCallback((player, cardIndex = 0) => {
    if (hands[player].length === 0) return;
    
    const newHands = hands.map(h => [...h]);
    const discarded = newHands[player].splice(cardIndex, 1)[0];
    const newDiscardPiles = discardPiles.map((pile, i) => 
      i === player ? [...pile, discarded] : [...pile]
    );
    const { card: newCard, newDeck, newDiscardPiles: updatedDiscardPiles } = drawCard(deck, newDiscardPiles);
    if (newCard) newHands[player].push(newCard);
    
    const newStuckCounts = [...stuckCounts];
    newStuckCounts[player] = stuckCounts[player] + 1;
    const drewStartCard = newCard && CARD_VALUES[newCard.rank]?.canStart;
    if (drewStartCard) {
      newStuckCounts[player] = 0;
    }
    
    let newPegs = pegs;
    if (newStuckCounts[player] >= 3) {
      const pegInStart = pegs[player].findIndex(p => p.location === 'start');
      if (pegInStart !== -1) {
        const startPos = getStartPosition(player);
        const pegAtStart = findPegAtPosition(startPos, pegs);
        const ownPegAtStart = pegs[player].some(p => p.location === 'track' && p.position === startPos);
        if (!ownPegAtStart) {
          newPegs = pegs.map((playerPegs, i) => playerPegs.map(peg => ({ ...peg })));
          if (pegAtStart && pegAtStart.player !== player) {
            newPegs[pegAtStart.player][pegAtStart.pegIndex] = { location: 'start', index: pegAtStart.pegIndex };
          }
          newPegs[player][pegInStart].location = 'track';
          newPegs[player][pegInStart].position = startPos;
          newStuckCounts[player] = 0;
          if (player === 0) {
            setGameMessage('After 3 stuck turns, you start a peg!');
          }
        }
      }
      newStuckCounts[player] = 0;
    }
    
    setPegs(newPegs);
    setHands(newHands);
    setDeck(newDeck);
    setDiscardPiles(updatedDiscardPiles);
    setStuckCounts(newStuckCounts);
    setSelectedCard(null);
    setSelectedPeg(null);
    setDiscardMode(false);
    
    if (player === 0) {
      const nextPlayer = 1;
      setCurrentPlayer(nextPlayer);
      if (newStuckCounts[0] === 0 && newPegs !== pegs) {
        setTimeout(() => setGameMessage(`${PLAYER_NAMES[nextPlayer]} is thinking...`), 1500);
      } else {
        setGameMessage(`${PLAYER_NAMES[nextPlayer]} is thinking...`);
      }
    }
  }, [hands, deck, discardPiles, stuckCounts, pegs, drawCard, findPegAtPosition]);

  // AI logic
  useEffect(() => {
    if (currentPlayer === 0 || winner !== null) return;
    
    const aiPlayer = currentPlayer;
    const nextPlayer = (currentPlayer + 1) % 4;
    
    const timer = setTimeout(() => {
      const aiHand = hands[aiPlayer];
      
      const completeAIMove = (newPegs, card) => {
        setPegs(newPegs);
        const newHands = hands.map(h => [...h]);
        const cardIndex = newHands[aiPlayer].findIndex(c => c.id === card.id);
        const discarded = newHands[aiPlayer].splice(cardIndex, 1)[0];
        const newDiscardPiles = discardPiles.map((pile, i) => 
          i === aiPlayer ? [...pile, discarded] : [...pile]
        );
        const { card: newCard, newDeck, newDiscardPiles: updatedDiscardPiles } = drawCard(deck, newDiscardPiles);
        if (newCard) newHands[aiPlayer].push(newCard);
        setHands(newHands);
        setDeck(newDeck);
        setDiscardPiles(updatedDiscardPiles);
        const newStuckCounts = [...stuckCounts];
        newStuckCounts[aiPlayer] = 0;
        setStuckCounts(newStuckCounts);
        const w = checkWinner(newPegs);
        if (w !== null) {
          setWinner(w);
          return true;
        }
        setCurrentPlayer(nextPlayer);
        if (nextPlayer === 0) {
          setGameMessage('Your turn! Select a card and peg to move.');
        } else {
          setGameMessage(`${PLAYER_NAMES[nextPlayer]} is thinking...`);
        }
        return false;
      };
      
      const getTotalDistance = (pegState) => {
        return pegState[aiPlayer].reduce((sum, peg) => sum + getDistanceToHome(peg, aiPlayer), 0);
      };
      
      const possibleMoves = [];
      
      for (const card of aiHand) {
        const cardInfo = CARD_VALUES[card.rank];
        
        for (let pegIndex = 0; pegIndex < 5; pegIndex++) {
          const peg = pegs[aiPlayer][pegIndex];
          if (peg.location === 'home' && peg.homePosition === 4) continue;
          
          if (!cardInfo.canSplit && !cardInfo.mustSplit && !cardInfo.isJoker) {
            if (isValidMove(aiPlayer, pegIndex, card, pegs)) {
              const { newPegs } = executeMoveInternal(aiPlayer, pegIndex, card, null, pegs);
              const improvement = getTotalDistance(pegs) - getTotalDistance(newPegs);
              possibleMoves.push({
                card, pegIndex, newPegs, improvement,
                bonus: peg.location === 'home' ? 10 : 0
              });
            }
          }
          
          if (cardInfo.canSplit) {
            if (isValidMove(aiPlayer, pegIndex, card, pegs, 7)) {
              const { newPegs } = executeMoveInternal(aiPlayer, pegIndex, card, 7, pegs);
              const improvement = getTotalDistance(pegs) - getTotalDistance(newPegs);
              possibleMoves.push({
                card, pegIndex, amount: 7, newPegs, improvement,
                bonus: peg.location === 'home' ? 10 : 0
              });
            }
            for (let split = 1; split <= 6; split++) {
              if (isValidMove(aiPlayer, pegIndex, card, pegs, split)) {
                const { newPegs: afterFirst } = executeMoveInternal(aiPlayer, pegIndex, card, split, pegs);
                const remaining = 7 - split;
                for (let secondPeg = 0; secondPeg < 5; secondPeg++) {
                  if (secondPeg === pegIndex) continue;
                  if (isValidMove(aiPlayer, secondPeg, card, afterFirst, remaining)) {
                    const { newPegs: finalPegs } = executeMoveInternal(aiPlayer, secondPeg, card, remaining, afterFirst);
                    const improvement = getTotalDistance(pegs) - getTotalDistance(finalPegs);
                    possibleMoves.push({
                      card, pegIndex, amount: split, newPegs: finalPegs, improvement,
                      bonus: (pegs[aiPlayer][pegIndex].location === 'home' ? 10 : 0) + 
                             (afterFirst[aiPlayer][secondPeg].location === 'home' ? 10 : 0)
                    });
                  }
                }
              }
            }
          }
          
          if (cardInfo.mustSplit) {
            for (let forward = 1; forward <= 8; forward++) {
              const backward = -(9 - forward);
              if (isValidMove(aiPlayer, pegIndex, card, pegs, forward)) {
                const { newPegs: afterFirst } = executeMoveInternal(aiPlayer, pegIndex, card, forward, pegs);
                for (let secondPeg = 0; secondPeg < 5; secondPeg++) {
                  if (secondPeg === pegIndex) continue;
                  if (isValidMove(aiPlayer, secondPeg, card, afterFirst, backward)) {
                    const { newPegs: finalPegs } = executeMoveInternal(aiPlayer, secondPeg, card, backward, afterFirst);
                    const improvement = getTotalDistance(pegs) - getTotalDistance(finalPegs);
                    possibleMoves.push({
                      card, pegIndex, amount: forward, newPegs: finalPegs, improvement,
                      bonus: pegs[aiPlayer][pegIndex].location === 'home' ? 10 : 0
                    });
                  }
                }
              }
            }
          }
          
          if (cardInfo.canStart && peg.location === 'start') {
            if (isValidMove(aiPlayer, pegIndex, card, pegs)) {
              const { newPegs } = executeMoveInternal(aiPlayer, pegIndex, card, null, pegs);
              const improvement = getTotalDistance(pegs) - getTotalDistance(newPegs);
              possibleMoves.push({
                card, pegIndex, newPegs, improvement, bonus: -5
              });
            }
          }
          
          if (cardInfo.isJoker && (peg.location === 'start' || peg.location === 'track')) {
            for (let oppPlayer = 0; oppPlayer < 4; oppPlayer++) {
              if (oppPlayer === aiPlayer) continue;
              for (let oppPeg = 0; oppPeg < 5; oppPeg++) {
                const opponentPeg = pegs[oppPlayer][oppPeg];
                if (opponentPeg.location === 'track') {
                  const newPegs = pegs.map(p => p.map(pg => ({ ...pg })));
                  newPegs[oppPlayer][oppPeg] = { location: 'start', index: oppPeg };
                  newPegs[aiPlayer][pegIndex].location = 'track';
                  newPegs[aiPlayer][pegIndex].position = opponentPeg.position;
                  const improvement = getTotalDistance(pegs) - getTotalDistance(newPegs);
                  possibleMoves.push({
                    card, pegIndex, newPegs, improvement, bonus: 5
                  });
                }
              }
            }
          }
        }
      }
      
      possibleMoves.sort((a, b) => (b.improvement + b.bonus) - (a.improvement + a.bonus));
      
      if (possibleMoves.length > 0) {
        const bestMove = possibleMoves[0];
        if (completeAIMove(bestMove.newPegs, bestMove.card)) return;
        return;
      }
      
      discardAndDraw(aiPlayer);
      setCurrentPlayer(nextPlayer);
      if (nextPlayer === 0) {
        setGameMessage('Your turn! Select a card and peg to move.');
      } else {
        setGameMessage(`${PLAYER_NAMES[nextPlayer]} is thinking...`);
      }
    }, 800);
    
    return () => clearTimeout(timer);
  }, [currentPlayer, winner, hands, pegs, deck, discardPiles, stuckCounts, isValidMove, executeMoveInternal, drawCard, checkWinner, discardAndDraw]);

  const handleCardClick = (cardIndex) => {
    if (currentPlayer !== 0 || winner !== null) return;
    if (splitRemaining !== 0) return;
    if (discardMode) {
      discardAndDraw(0, cardIndex);
      return;
    }
    if (jokerMode) {
      setJokerMode(false);
      setJokerSourcePeg(null);
      setSelectedPeg(null);
    }
    setSelectedCard(cardIndex);
  };

  const handlePegClick = (player, pegIndex) => {
    if (currentPlayer !== 0 || winner !== null) return;
    if (jokerMode && player === 0) {
      setJokerMode(false);
      setJokerSourcePeg(null);
      setSelectedPeg(null);
      setGameMessage('Joker cancelled. Select a card and peg to move.');
      return;
    }
    if (player !== 0) return;
    if (splitRemaining !== 0) {
      completeSplit(pegIndex, splitRemaining);
      return;
    }
    if (selectedCard === null) {
      setGameMessage('Select a card first.');
      return;
    }
    setSelectedPeg(pegIndex);
    const card = hands[0][selectedCard];
    const cardInfo = CARD_VALUES[card.rank];
    if (cardInfo.isJoker) {
      setJokerMode(true);
      setJokerSourcePeg(pegIndex);
      setGameMessage('Now click an opponent\'s peg on the track to bump it.');
      return;
    }
    if (cardInfo.canSplit && (pegs[0][pegIndex].location === 'track' || pegs[0][pegIndex].location === 'home')) {
      setGameMessage('Click Move button to use full 7, or select split amount.');
    } else if (cardInfo.mustSplit && (pegs[0][pegIndex].location === 'track' || pegs[0][pegIndex].location === 'home')) {
      setGameMessage('Select split: forward amount for this peg, backward for another peg.');
    } else {
      executeMove(0, pegIndex, card);
    }
  };

  const handleJokerTarget = (targetPlayer, targetPegIndex) => {
    if (!jokerMode || jokerSourcePeg === null || selectedCard === null) return;
    if (targetPlayer === 0) return;
    const targetPeg = pegs[targetPlayer][targetPegIndex];
    if (targetPeg.location !== 'track') return;
    const card = hands[0][selectedCard];
    const newPegs = pegs.map(p => p.map(peg => ({ ...peg })));
    const sourcePeg = newPegs[0][jokerSourcePeg];
    const targetPos = targetPeg.position;
    newPegs[targetPlayer][targetPegIndex] = { location: 'start', index: targetPegIndex };
    sourcePeg.location = 'track';
    sourcePeg.position = targetPos;
    setPegs(newPegs);
    const newHands = hands.map(h => [...h]);
    const cardIndex = newHands[0].findIndex(c => c.id === card.id);
    const discarded = newHands[0].splice(cardIndex, 1)[0];
    const newDiscardPiles = discardPiles.map((pile, i) => 
      i === 0 ? [...pile, discarded] : [...pile]
    );
    const { card: newCard, newDeck, newDiscardPiles: updatedDiscardPiles } = drawCard(deck, newDiscardPiles);
    if (newCard) newHands[0].push(newCard);
    setHands(newHands);
    setDeck(newDeck);
    setDiscardPiles(updatedDiscardPiles);
    const newStuckCounts = [...stuckCounts];
    newStuckCounts[0] = 0;
    setStuckCounts(newStuckCounts);
    setSelectedCard(null);
    setSelectedPeg(null);
    setJokerMode(false);
    setJokerSourcePeg(null);
    const w = checkWinner(newPegs);
    if (w !== null) {
      setWinner(w);
      return;
    }
    const nextPlayer = 1;
    setCurrentPlayer(nextPlayer);
    setGameMessage(`${PLAYER_NAMES[nextPlayer]} is thinking...`);
  };

  const handleMoveClick = (amount = null) => {
    if (selectedCard === null || selectedPeg === null) return;
    const card = hands[0][selectedCard];
    executeMove(0, selectedPeg, card, amount);
  };

  const BOARD_SIZE = 400;
  const MARGIN = 40;
  const SPACES_PER_SIDE = 18;

  const getTrackPosition = (index) => {
    const side = Math.floor(index / SPACES_PER_SIDE);
    const posOnSide = index % SPACES_PER_SIDE;
    const spacing = (BOARD_SIZE - 2 * MARGIN) / (SPACES_PER_SIDE - 1);
    switch (side) {
      case 0:
        return { x: MARGIN + posOnSide * spacing, y: MARGIN };
      case 1:
        return { x: BOARD_SIZE - MARGIN, y: MARGIN + posOnSide * spacing };
      case 2:
        return { x: BOARD_SIZE - MARGIN - posOnSide * spacing, y: BOARD_SIZE - MARGIN };
      case 3:
        return { x: MARGIN, y: BOARD_SIZE - MARGIN - posOnSide * spacing };
      default:
        return { x: 0, y: 0 };
    }
  };

  const getStartPosition_UI = (player, pegIndex) => {
    const trackPos = player * 18 + 8;
    const { x: trackX, y: trackY } = getTrackPosition(trackPos);
    const offsets = [
      { dx: 0, dy: 30 },
      { dx: -30, dy: 0 },
      { dx: 0, dy: -30 },
      { dx: 30, dy: 0 }
    ];
    const baseOffset = offsets[player];
    const pegOffsets = [
      { dx: 0, dy: 0 },
      { dx: -12, dy: -12 },
      { dx: 12, dy: -12 },
      { dx: -12, dy: 12 },
      { dx: 12, dy: 12 }
    ];
    const pegOff = pegOffsets[pegIndex];
    if (player === 0 || player === 2) {
      return {
        x: trackX + baseOffset.dx + pegOff.dx,
        y: trackY + baseOffset.dy + (player === 0 ? pegOff.dy : -pegOff.dy)
      };
    } else {
      return {
        x: trackX + baseOffset.dx + (player === 1 ? -pegOff.dy : pegOff.dy),
        y: trackY + baseOffset.dy + pegOff.dx
      };
    }
  };

  const getHomePosition = (player, index) => {
    const trackPos = player * 18 + 3;
    const { x: trackX, y: trackY } = getTrackPosition(trackPos);
    const directions = [
      { dx: 0, dy: 1 },
      { dx: -1, dy: 0 },
      { dx: 0, dy: -1 },
      { dx: 1, dy: 0 }
    ];
    const dir = directions[player];
    const spacing = 18;
    return {
      x: trackX + dir.dx * (index + 1) * spacing,
      y: trackY + dir.dy * (index + 1) * spacing
    };
  };

  const renderCard = (card, index, isSelected) => {
    const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
    const discardHighlight = discardMode ? 'ring-2 ring-red-400 hover:ring-red-300' : '';
    return (
      <div
        key={card.id}
        onClick={() => handleCardClick(index)}
        className={`cursor-pointer transition-transform ${isSelected ? 'ring-2 ring-yellow-400 -translate-y-2' : 'hover:-translate-y-1'} ${discardHighlight}`}
        style={{
          width: 50,
          height: 70,
          backgroundColor: discardMode ? '#FEE2E2' : 'white',
          border: '1px solid #ccc',
          borderRadius: 4,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          color: isRed ? '#DC2626' : '#1F2937',
          fontWeight: 'bold',
          fontSize: card.rank === '10' ? 12 : 14
        }}
      >
        <span>{card.rank}</span>
        <span>{card.suit}</span>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white p-2 sm:p-4">
      <div className="max-w-5xl mx-auto">
        <div className="flex justify-between items-center mb-4">
          <h1 className="text-2xl font-bold">Pegs and Jokers</h1>
          <button
            onClick={initGame}
            className="px-4 py-2 bg-blue-600 rounded hover:bg-blue-700"
          >
            New Game
          </button>
        </div>

        {winner !== null && (
          <div className="text-center mb-4 p-4 bg-green-700 rounded text-xl font-bold">
            {winner === 0 ? 'You win!' : `${PLAYER_NAMES[winner]} wins!`}
          </div>
        )}

        <div className="text-center mb-4 p-2 bg-gray-800 rounded">
          {gameMessage}
        </div>

        <div className="flex flex-col lg:flex-row gap-4 items-center lg:items-start">
          <div className="flex-shrink-0 w-full max-w-[400px]">
            <svg viewBox="0 0 400 400" className="w-full h-auto bg-gray-800 rounded">
              {Array.from({ length: TRACK_LENGTH }).map((_, i) => {
                const { x, y } = getTrackPosition(i);
                const isHomeEntrance = i % SPACES_PER_SIDE === 3;
                const playerSection = Math.floor(i / SPACES_PER_SIDE);
                return (
                  <circle
                    key={`track-${i}`}
                    cx={x}
                    cy={y}
                    r={6}
                    fill="#4B5563"
                    stroke={isHomeEntrance ? PLAYER_COLORS[playerSection] : '#374151'}
                    strokeWidth={isHomeEntrance ? 2 : 1}
                  />
                );
              })}

              {[0, 1, 2, 3].map(player => (
                <g key={`start-${player}`}>
                  {Array.from({ length: 5 }).map((_, i) => {
                    const { x, y } = getStartPosition_UI(player, i);
                    const hasPeg = pegs[player].some(p => p.location === 'start' && p.index === i);
                    const pegIndex = pegs[player].findIndex(p => p.location === 'start' && p.index === i);
                    const isClickable = currentPlayer === 0 && player === 0 && hasPeg && !jokerMode;
                    const isSelected = player === 0 && pegIndex === selectedPeg && hasPeg;
                    return (
                      <circle
                        key={`start-${player}-${i}`}
                        cx={x}
                        cy={y}
                        r={5}
                        fill={hasPeg ? PLAYER_COLORS[player] : '#374151'}
                        stroke={isSelected ? 'white' : PLAYER_COLORS[player]}
                        strokeWidth={isSelected ? 2 : 1.5}
                        style={{ cursor: isClickable ? 'pointer' : 'default' }}
                        onClick={() => isClickable && handlePegClick(player, pegIndex)}
                      />
                    );
                  })}
                </g>
              ))}

              {[0, 1, 2, 3].map(player => (
                <g key={`home-${player}`}>
                  {Array.from({ length: 5 }).map((_, i) => {
                    const { x, y } = getHomePosition(player, i);
                    const hasPeg = pegs[player].some(p => p.location === 'home' && p.homePosition === i);
                    const pegIndex = pegs[player].findIndex(p => p.location === 'home' && p.homePosition === i);
                    const isClickable = currentPlayer === 0 && player === 0 && hasPeg && i < 4 && !jokerMode;
                    const isSelected = player === 0 && pegIndex === selectedPeg && hasPeg;
                    return (
                      <circle
                        key={`home-${player}-${i}`}
                        cx={x}
                        cy={y}
                        r={5}
                        fill={hasPeg ? PLAYER_COLORS[player] : '#374151'}
                        stroke={isSelected ? 'white' : PLAYER_COLORS[player]}
                        strokeWidth={isSelected ? 2 : 1.5}
                        style={{ cursor: isClickable ? 'pointer' : 'default' }}
                        onClick={() => isClickable && handlePegClick(player, pegIndex)}
                      />
                    );
                  })}
                </g>
              ))}

              {pegs.map((playerPegs, player) =>
                playerPegs.map((peg, pegIndex) => {
                  if (peg.location === 'start' || peg.location === 'home') return null;
                  let pos;
                  if (peg.location === 'track') {
                    pos = getTrackPosition(peg.position);
                  }
                  if (!pos) return null;
                  const isJokerTarget = jokerMode && player !== 0 && peg.location === 'track';
                  const isJokerSource = jokerMode && player === 0 && pegIndex === jokerSourcePeg;
                  const isClickable = currentPlayer === 0 && (player === 0 || isJokerTarget);
                  const isSelected = player === 0 && (pegIndex === selectedPeg || isJokerSource);
                  return (
                    <circle
                      key={`peg-${player}-${pegIndex}`}
                      cx={pos.x}
                      cy={pos.y}
                      r={7}
                      fill={PLAYER_COLORS[player]}
                      stroke={isSelected ? 'white' : (isJokerTarget ? '#EF4444' : '#1F2937')}
                      strokeWidth={isSelected ? 2 : (isJokerTarget ? 3 : 1)}
                      style={{ cursor: isClickable ? 'pointer' : 'default' }}
                      onClick={() => {
                        if (!isClickable) return;
                        if (isJokerTarget && player !== 0) {
                          handleJokerTarget(player, pegIndex);
                        } else if (player === 0) {
                          if (jokerMode) {
                            setJokerMode(false);
                            setJokerSourcePeg(null);
                            setSelectedPeg(null);
                            setGameMessage('Joker cancelled. Select a card and peg to move.');
                          } else {
                            handlePegClick(player, pegIndex);
                          }
                        }
                      }}
                    />
                  );
                })
              )}

              <g>
                <rect x="175" y="185" width="25" height="35" rx="2" fill="#1E3A5F" stroke="#3B82F6" strokeWidth="2" />
                <rect x="177" y="187" width="25" height="35" rx="2" fill="#1E3A5F" stroke="#3B82F6" strokeWidth="1" />
                <rect x="179" y="189" width="25" height="35" rx="2" fill="#1E3A5F" stroke="#3B82F6" strokeWidth="1" />
                <text x="191" y="212" textAnchor="middle" fill="white" fontSize="12" fontWeight="bold">{deck.length}</text>
              </g>

              {[0, 1, 2, 3].map(player => {
                const positions = [
                  { x: 120, y: 100 },
                  { x: 270, y: 100 },
                  { x: 270, y: 270 },
                  { x: 120, y: 270 }
                ];
                const pos = positions[player];
                const lastCard = discardPiles[player]?.[discardPiles[player].length - 1];
                const stuckCount = stuckCounts[player];
                return (
                  <g key={`discard-${player}`}>
                    {lastCard ? (
                      <g>
                        <rect x={pos.x} y={pos.y} width="22" height="30" rx="2" fill="white" stroke={PLAYER_COLORS[player]} strokeWidth="1.5" />
                        <text 
                          x={pos.x + 11} 
                          y={pos.y + 14} 
                          textAnchor="middle" 
                          fill={lastCard.suit === 'â™¥' || lastCard.suit === 'â™¦' ? '#DC2626' : '#1F2937'} 
                          fontSize="8" 
                          fontWeight="bold"
                        >
                          {lastCard.rank}
                        </text>
                        <text 
                          x={pos.x + 11} 
                          y={pos.y + 25} 
                          textAnchor="middle" 
                          fill={lastCard.suit === 'â™¥' || lastCard.suit === 'â™¦' ? '#DC2626' : '#1F2937'} 
                          fontSize="9"
                        >
                          {lastCard.suit}
                        </text>
                      </g>
                    ) : (
                      <rect x={pos.x} y={pos.y} width="22" height="30" rx="2" fill="none" stroke={PLAYER_COLORS[player]} strokeWidth="1" strokeDasharray="3" opacity="0.5" />
                    )}
                    {stuckCount > 0 && (
                      <g>
                        <rect x={pos.x + 26} y={pos.y} width="22" height="30" rx="2" fill="#4B5563" stroke="#6B7280" strokeWidth="1" />
                        <text x={pos.x + 37} y={pos.y + 20} textAnchor="middle" fill="white" fontSize="12" fontWeight="bold">{stuckCount}</text>
                      </g>
                    )}
                  </g>
                );
              })}

              <text x="200" y="25" textAnchor="middle" fill={PLAYER_COLORS[0]} fontSize="11" fontWeight="bold">You (Yellow)</text>
              <text x="378" y="205" textAnchor="middle" fill={PLAYER_COLORS[1]} fontSize="11" fontWeight="bold" transform="rotate(90 378 205)">Blue (AI)</text>
              <text x="200" y="388" textAnchor="middle" fill={PLAYER_COLORS[2]} fontSize="11" fontWeight="bold">Pink (AI)</text>
              <text x="22" y="205" textAnchor="middle" fill={PLAYER_COLORS[3]} fontSize="11" fontWeight="bold" transform="rotate(-90 22 205)">Green (AI)</text>
            </svg>
          </div>

          <div className="flex-1 w-full lg:w-auto">
            <div className="mb-4">
              <h3 className="text-lg font-semibold mb-2">Your Hand:</h3>
              <div className="flex gap-2 flex-wrap">
                {hands[0].map((card, i) => renderCard(card, i, i === selectedCard))}
              </div>
            </div>

            {selectedCard !== null && selectedPeg !== null && !jokerMode && (
              <div className="mb-4">
                <h3 className="text-lg font-semibold mb-2">Actions:</h3>
                <div className="flex gap-2 flex-wrap">
                  <button
                    onClick={() => handleMoveClick()}
                    className="px-3 py-1 bg-green-600 rounded hover:bg-green-700"
                  >
                    Move
                  </button>
                  {hands[0][selectedCard]?.rank === '7' && (pegs[0][selectedPeg]?.location === 'track' || pegs[0][selectedPeg]?.location === 'home') && (
                    <>
                      {[1, 2, 3, 4, 5, 6].map(n => (
                        <button
                          key={n}
                          onClick={() => handleMoveClick(n)}
                          className="px-3 py-1 bg-purple-600 rounded hover:bg-purple-700"
                        >
                          Split {n}/{7-n}
                        </button>
                      ))}
                    </>
                  )}
                  {hands[0][selectedCard]?.rank === '9' && (pegs[0][selectedPeg]?.location === 'track' || pegs[0][selectedPeg]?.location === 'home') && (
                    <>
                      {[1, 2, 3, 4, 5, 6, 7, 8].map(n => (
                        <button
                          key={n}
                          onClick={() => handleMoveClick(n)}
                          className="px-3 py-1 bg-purple-600 rounded hover:bg-purple-700"
                        >
                          +{n}/-{9-n}
                        </button>
                      ))}
                    </>
                  )}
                </div>
              </div>
            )}

            {jokerMode && (
              <div className="mb-4 p-3 bg-red-900 rounded">
                <p className="mb-2">Joker Mode: Click an opponent's peg on the track to bump it.</p>
                <button
                  onClick={() => {
                    setJokerMode(false);
                    setJokerSourcePeg(null);
                    setSelectedPeg(null);
                    setGameMessage('Joker cancelled. Select a card and peg to move.');
                  }}
                  className="px-3 py-1 bg-gray-600 rounded hover:bg-gray-700"
                >
                  Cancel Joker
                </button>
              </div>
            )}

            {discardMode && (
              <div className="mb-4 p-3 bg-yellow-900 rounded">
                <p className="mb-2 font-bold">Select a card to discard:</p>
                <p className="text-sm mb-2">Click on any card in your hand to discard it and draw a new card.</p>
                <button
                  onClick={() => {
                    setDiscardMode(false);
                    setGameMessage('Your turn! Select a card and peg to move.');
                  }}
                  className="px-3 py-1 bg-gray-600 rounded hover:bg-gray-700"
                >
                  Cancel
                </button>
              </div>
            )}

            {currentPlayer === 0 && !jokerMode && !splitRemaining && !discardMode && hands[0]?.length > 0 && (
              <div className="mb-4">
                {!hasAnyValidMove(0, hands[0], pegs) ? (
                  <div>
                    <button
                      onClick={() => {
                        setDiscardMode(true);
                        setSelectedCard(null);
                        setSelectedPeg(null);
                        setGameMessage('Select a card to discard.');
                      }}
                      className="px-4 py-2 bg-red-600 rounded hover:bg-red-700 font-bold"
                    >
                      No Valid Move - Select Card to Discard {stuckCounts[0] > 0 && `(${stuckCounts[0]}/3)`}
                    </button>
                    {stuckCounts[0] === 2 && (
                      <p className="text-yellow-400 text-sm mt-1">Next stuck discard will let you start a peg!</p>
                    )}
                  </div>
                ) : (
                  <button
                    onClick={() => {
                      setDiscardMode(true);
                      setSelectedCard(null);
                      setSelectedPeg(null);
                      setGameMessage('Select a card to discard.');
                    }}
                    className="px-4 py-2 bg-gray-600 rounded hover:bg-gray-700 text-sm"
                  >
                    Discard & Pass (if stuck)
                  </button>
                )}
              </div>
            )}

            <div className="mt-4 p-3 bg-gray-800 rounded text-sm">
              <h4 className="font-semibold mb-2">Quick Rules:</h4>
              <ul className="space-y-1 text-gray-300">
                <li>â€¢ A, J, Q, K: Move from START or move that many spaces</li>
                <li>â€¢ 2-6, 10: Move face value</li>
                <li>â€¢ 7: Split between two pegs (forward only)</li>
                <li>â€¢ 8: Move backward 8 spaces</li>
                <li>â€¢ 9: Split between two pegs (one forward, one backward)</li>
                <li>â€¢ Joker: Bump any opponent peg</li>
                <li>â€¢ Cannot jump or land on your own pegs</li>
                <li>â€¢ <span className="text-yellow-400">Stuck 3 turns OR draw A/J/Q/K = start a peg!</span></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<PegsAndJokers />);
  </script>
</body>
</html>
